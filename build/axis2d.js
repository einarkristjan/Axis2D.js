/*! Axis2D.js 0.1.0 */
// Generated by CoffeeScript 1.6.3
(function() {
  var AABB, Hit, Point, Sweep, abs, clamp, epsilon, intersect, sign;

  intersect = typeof exports !== "undefined" && exports !== null ? exports : (this.intersect != null ? this.intersect : this.intersect = {});

  intersect.epsilon = epsilon = 1e-8;

  intersect.abs = abs = function(value) {
    if (value < 0) {
      return -value;
    } else {
      return value;
    }
  };

  intersect.clamp = clamp = function(value, min, max) {
    if (value < min) {
      return min;
    } else if (value > max) {
      return max;
    } else {
      return value;
    }
  };

  intersect.sign = sign = function(value) {
    if (value < 0) {
      return -1;
    } else {
      return 1;
    }
  };

  intersect.Point = Point = (function() {
    function Point(x, y) {
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      this.x = x;
      this.y = y;
    }

    Point.prototype.clone = function() {
      return new Point(this.x, this.y);
    };

    Point.prototype.normalize = function() {
      var inverseLength, length;
      length = this.x * this.x + this.y * this.y;
      if (length > 0) {
        length = Math.sqrt(length);
        inverseLength = 1.0 / length;
        this.x *= inverseLength;
        this.y *= inverseLength;
      }
      return length;
    };

    return Point;

  })();

  intersect.Hit = Hit = (function() {
    function Hit(collider) {
      this.collider = collider;
      this.pos = new Point();
      this.delta = new Point();
      this.normal = new Point();
    }

    return Hit;

  })();

  intersect.Sweep = Sweep = (function() {
    function Sweep() {
      this.hit = null;
      this.pos = new Point();
      this.time = 1;
    }

    return Sweep;

  })();

  intersect.AABB = AABB = (function() {
    function AABB(pos, half) {
      this.pos = pos;
      this.half = half;
    }

    AABB.prototype.intersectPoint = function(point) {
      var dx, dy, hit, px, py, sx, sy;
      dx = point.x - this.pos.x;
      px = this.half.x - abs(dx);
      if (px <= 0) {
        return null;
      }
      dy = point.y - this.pos.y;
      py = this.half.y - abs(dy);
      if (py <= 0) {
        return null;
      }
      hit = new Hit(this);
      if (px < py) {
        sx = sign(dx);
        hit.delta.x = px * sx;
        hit.normal.x = sx;
        hit.pos.x = this.pos.x + (this.half.x * sx);
        hit.pos.y = point.y;
      } else {
        sy = sign(dy);
        hit.delta.y = py * sy;
        hit.normal.y = sy;
        hit.pos.x = point.x;
        hit.pos.y = this.pos.y + (this.half.y * sy);
      }
      return hit;
    };

    AABB.prototype.intersectSegment = function(pos, delta, paddingX, paddingY) {
      var farTime, farTimeX, farTimeY, hit, nearTime, nearTimeX, nearTimeY, scaleX, scaleY, signX, signY;
      if (paddingX == null) {
        paddingX = 0;
      }
      if (paddingY == null) {
        paddingY = 0;
      }
      scaleX = 1.0 / delta.x;
      scaleY = 1.0 / delta.y;
      signX = sign(scaleX);
      signY = sign(scaleY);
      nearTimeX = (this.pos.x - signX * (this.half.x + paddingX) - pos.x) * scaleX;
      nearTimeY = (this.pos.y - signY * (this.half.y + paddingY) - pos.y) * scaleY;
      farTimeX = (this.pos.x + signX * (this.half.x + paddingX) - pos.x) * scaleX;
      farTimeY = (this.pos.y + signY * (this.half.y + paddingY) - pos.y) * scaleY;
      if (nearTimeX > farTimeY || nearTimeY > farTimeX) {
        return null;
      }
      nearTime = nearTimeX > nearTimeY ? nearTimeX : nearTimeY;
      farTime = farTimeX < farTimeY ? farTimeX : farTimeY;
      if (nearTime >= 1 || farTime <= 0) {
        return null;
      }
      hit = new Hit(this);
      hit.time = clamp(nearTime, 0, 1);
      if (nearTimeX > nearTimeY) {
        hit.normal.x = -signX;
        hit.normal.y = 0;
      } else {
        hit.normal.x = 0;
        hit.normal.y = -signY;
      }
      hit.delta.x = hit.time * delta.x;
      hit.delta.y = hit.time * delta.y;
      hit.pos.x = pos.x + hit.delta.x;
      hit.pos.y = pos.y + hit.delta.y;
      return hit;
    };

    AABB.prototype.intersectAABB = function(box) {
      var dx, dy, hit, px, py, sx, sy;
      dx = box.pos.x - this.pos.x;
      px = (box.half.x + this.half.x) - abs(dx);
      if (px <= 0) {
        return null;
      }
      dy = box.pos.y - this.pos.y;
      py = (box.half.y + this.half.y) - abs(dy);
      if (py <= 0) {
        return null;
      }
      hit = new Hit(this);
      if (px < py) {
        sx = sign(dx);
        hit.delta.x = px * sx;
        hit.normal.x = sx;
        hit.pos.x = this.pos.x + (this.half.x * sx);
        hit.pos.y = box.pos.y;
      } else {
        sy = sign(dy);
        hit.delta.y = py * sy;
        hit.normal.y = sy;
        hit.pos.x = box.pos.x;
        hit.pos.y = this.pos.y + (this.half.y * sy);
      }
      return hit;
    };

    AABB.prototype.sweepAABB = function(box, delta) {
      var direction, sweep;
      sweep = new Sweep();
      if (delta.x === 0 && delta.y === 0) {
        sweep.pos.x = box.pos.x;
        sweep.pos.y = box.pos.y;
        sweep.hit = this.intersectAABB(box);
        if (sweep.hit != null) {
          sweep.time = sweep.hit.time = 0;
        } else {
          sweep.time = 1;
        }
      } else {
        sweep.hit = this.intersectSegment(box.pos, delta, box.half.x, box.half.y);
        if (sweep.hit != null) {
          sweep.time = clamp(sweep.hit.time - epsilon, 0, 1);
          sweep.pos.x = box.pos.x + delta.x * sweep.time;
          sweep.pos.y = box.pos.y + delta.y * sweep.time;
          direction = delta.clone();
          direction.normalize();
          sweep.hit.pos.x += direction.x * box.half.x;
          sweep.hit.pos.y += direction.y * box.half.y;
        } else {
          sweep.pos.x = box.pos.x + delta.x;
          sweep.pos.y = box.pos.y + delta.y;
          sweep.time = 1;
        }
      }
      return sweep;
    };

    AABB.prototype.sweepInto = function(staticColliders, delta) {
      var collider, nearest, sweep, _i, _len;
      nearest = new Sweep();
      nearest.time = 1;
      nearest.pos.x = this.pos.x + delta.x;
      nearest.pos.y = this.pos.y + delta.y;
      for (_i = 0, _len = staticColliders.length; _i < _len; _i++) {
        collider = staticColliders[_i];
        sweep = collider.sweepAABB(this, delta);
        if (sweep.time < nearest.time) {
          nearest = sweep;
        }
      }
      return nearest;
    };

    return AABB;

  })();

}).call(this);

/*
//@ sourceMappingURL=intersect.map
*/

// namespace
Axis2D = { version: '0.1.0' };

// helpers
Axis2D.typeCheck = function(variable, varName, type) {
  var error = false,
      errorTxt = '',
      varObjName = variable.constructor.toString();

  varObjName = varObjName.match(/function (.*)\(/)[1];

  if(typeof type === 'string' && type !== varObjName) {
    error = true;
  }
  else if(typeof type === 'function' && !(variable instanceof type)) {
    error = true;
  }

  if(error) {
    errorTxt += 'In last stack call, ';
    errorTxt += 'parameter "'+varName+'" should be of type: ' + type;
    throw new TypeError(errorTxt);
  }
};

// export
if(typeof module === 'object') {
  module.exports = Axis2D;
}

Axis2D.World = function World(cellSize) {
  if(cellSize) {
    Axis2D.typeCheck(cellSize, 'cellSize', 'Number');
  }

  this._grid = new Axis2D.Grid(this, cellSize);

  this._colliders = [];
  this._collidersHit = [];
  this._responses = {};
  this._debugDraw = undefined;
  this._collisionCallback = undefined;

  // dynamic colliders are colliders that have moved or be resized
  this._dynamicColliders = [];

  // create default responses
  this.createResponseType('touch', function(collider){
    var sweep = collider._sweepToDelta();

    if(sweep.hit) {
      // stop on first hit
      collider._delta.x = 0;
      collider._delta.y = 0;
    }
  });

  this.createResponseType('slide', function(collider){
    var sweep = collider._sweepToDelta();

    if(sweep.hit) {
      // slide - undo the normal hit delta
      if(sweep.hit.normal.x) {
        collider._delta.x = 0;
      }
      else if(sweep.hit.normal.y) {
        collider._delta.y = 0;
      }

      // second sweep
      sweep = collider._sweepToDelta();

      if(sweep.hit) {
        // if we got a hit on second run.. _sweepToDelta has fixed pos
        collider._delta.x = 0;
        collider._delta.y = 0;
      }
    }
  });

  this.createResponseType('bounce', function(collider){
    var sweep = collider._sweepToDelta();

    if(sweep.hit) {
      // bounce - mirror the delta before next sweep
      if(sweep.hit.normal.x) {
        collider._delta.x = -collider._delta.x;
      }
      if(sweep.hit.normal.y) {
        collider._delta.y = -collider._delta.y;
      }

      // second sweep
      sweep = collider._sweepToDelta();

      if(sweep.hit) {
        // if we got a hit on second run.. _sweepToDelta has fixed pos
        collider._delta.x = 0;
        collider._delta.y = 0;
      }
    }
  });

};

Axis2D.World.prototype = {
  update: function() {
    // first pass - clear last hits - beginning of update for scripting
    // outside of Axis2D.
    this._collidersHit.forEach(function(c){
      c._hits = [];
      c._lastHitPositions = [];
      c._isTouching.top = false;
      c._isTouching.left = false;
      c._isTouching.right = false;
      c._isTouching.bottom = false;
    }, this);
    this._collidersHit = [];

    // second pass - sweep dynamic colliders into other colliders + add hits
    this._dynamicColliders.forEach(function(collider){
      var sweep;

      // sensor is a hard-coded response type that overwrites other types
      if(collider.isSensor()) {
        // sensor hits added in sweepToDelta,
        // because sensors move through many colliders
        sweep = collider._sweepToDelta();
      }
      else {
        this._responses[collider.getResponseType()].call(this, collider);
      }

      // fix position if any delta is left after responses
      collider._AABB.pos.x += collider._delta.x;
      collider._AABB.pos.y += collider._delta.y;

      this._grid._placeColliderInGrid(collider);

      // cleanups
      collider._potentialHitColliders = [];
      collider._isDynamic = false;
      collider._delta.x = 0;
      collider._delta.y = 0;
    }, this);
    this._dynamicColliders = [];

    // third pass - return hits for static and dynamic
    this._collidersHit.forEach(function(c){
      c._calculateTouches();
      if(c._collisionCallback) {
        c._collisionCallback(c.getHits(), c.getTouches());
      }
    }, this);

    if(this._collisionCallback && this._collidersHit.length) {
      this._collisionCallback(this._collidersHit);
    }
  },
  createCollider: function(centerX, centerY, width, height) {
    return new Axis2D.Collider(this, centerX, centerY, width, height);
  },
  removeCollider: function(collider) {
    Axis2D.typeCheck(collider, 'collider', Axis2D.Collider);
    var collidersIndex = this._colliders.indexOf(collider),
        dynamicCollidersIndex = this._dynamicColliders.indexOf(collider);

    this._grid._clearColliderFromGrid(collider);

    if(collidersIndex !== -1) {
      this._colliders.splice(collidersIndex, 1);
    }
    if(dynamicCollidersIndex !== -1) {
      this._dynamicColliders.splice(dynamicCollidersIndex, 1);
    }
  },
  createDebugDraw: function() {
    return new Axis2D.DebugDraw(this);
  },
  debugDraw: function() {
    Axis2D.typeCheck(this._debugDraw, 'this._debugDraw', Axis2D.DebugDraw);
    this._debugDraw._draw();
  },
  createResponseType: function(name, response) {
    Axis2D.typeCheck(name, 'name', 'String');
    Axis2D.typeCheck(response, 'response', 'Function');
    this._responses[name] = response;
  },
  getCollidersHit: function() {
    return this._collidersHit;
  },
  setCollisionCallback: function(callback) {
    Axis2D.typeCheck(callback, 'callback', 'Function');
    this._collisionCallback = callback;
  },
  getColliders: function() {
    return this._colliders;
  },
  countColliders: function() {
    return this._colliders.length;
  },
  countGridCells: function() {
    return Object.keys(this._grid._cells).length;
  },
  setCellSize: function(cellSize) {
    Axis2D.typeCheck(cellSize, 'cellSize', 'Number');

    this._grid._cellSize = cellSize;

    this._colliders.forEach(function(collider){
      this._grid._placeColliderInGrid(collider);
    }, this);
  },
  queryPoint: function(x, y) {
    Axis2D.typeCheck(x, 'x', 'Number');
    Axis2D.typeCheck(x, 'y', 'Number');

    var colliders = [],
        keyX = Math.floor(x/this._grid._cellSize),
        keyY = Math.floor(y/this._grid._cellSize),
        key = 'x'+keyX+'y'+keyY;

    if(this._grid._cells[key]) {
      this._grid._cells[key].forEach(function(collider){
        if(collider._AABB.intersectPoint(new intersect.Point(x, y))) {
          colliders.push(collider);
        }
      }, this);
    }

    return colliders;
  },
  queryRect: function(centerX, centerY, width, height) {
    Axis2D.typeCheck(centerX, 'centerX', 'Number');
    Axis2D.typeCheck(centerY, 'centerY', 'Number');
    Axis2D.typeCheck(width, 'width', 'Number');
    Axis2D.typeCheck(height, 'height', 'Number');

    var colliders = [],
        sensor = this.createCollider(centerX, centerY, width, height);

    sensor.setSensor(true);
    sensor._placeInPotentialGrid();

    sensor._potentialHitColliders.forEach(function(oc){
      if(sensor._AABB.intersectAABB(oc._AABB)) {
        colliders.push(oc);
      }
    }, true);

    this.removeCollider(sensor);

    return colliders;
  },
  rayCast: function(callback, x1, y1, x2, y2, groupFilter) {
    Axis2D.typeCheck(callback, 'callback', 'Function');
    Axis2D.typeCheck(x1, 'x1', 'Number');
    Axis2D.typeCheck(y1, 'y1', 'Number');
    Axis2D.typeCheck(x2, 'x2', 'Number');
    Axis2D.typeCheck(y2, 'y2', 'Number');

    var sweep,
        endX = x2,
        endY = y2,
        hits = [],
        collider = this.createCollider(x1, y1, 1, 1);

    collider._delta.x = x2 - x1;
    collider._delta.y = y2 - y1;

    if(groupFilter) {
      Axis2D.typeCheck(groupFilter, 'groupFilter', 'Array');
      collider.setGroupFilters(groupFilter);
    }

    sweep = collider._sweepToDelta();

    if(collider._hits.length) {
      hits = collider._hits.slice();
    }

    if(sweep.hit) {
      endX = sweep.hit.pos.x;
      endY = sweep.hit.pos.y;
    }

    this.removeCollider(collider);

    callback(new intersect.Point(endX, endY), hits);
  }
};

Axis2D.Grid = function World(axisWorld, cellSize) {
  Axis2D.typeCheck(axisWorld, 'axisWorld', Axis2D.World);
  if(cellSize) {
    Axis2D.typeCheck(cellSize, 'cellSize', 'Number');
  }

  this._axisWorld = axisWorld;

  this._cellSize = Math.abs(cellSize) || 64;
  this._cells = {};
};

Axis2D.Grid.prototype = {
  _placeColliderInGrid: function(collider) {
    // delete from last main grid position
    this._clearColliderFromGrid(collider);

    this._getColliderKeysInGrid(collider).forEach(function(key){
      if(!this._cells[key]) {
        this._cells[key] = [];
      }

      if(this._cells[key].indexOf(collider) === -1) {
        collider._positionInGridKeys.push(key);
        this._cells[key].push(collider);
      }
    }, this);
  },
  _clearColliderFromGrid: function(collider) {
    var gKey;
    // delete from main grid
    collider._positionInGridKeys.forEach(function(cgKey){
      gKey = this._cells[cgKey];

      gKey.splice(gKey.indexOf(collider), 1);

      if(!gKey.length) {
        delete this._cells[cgKey];
      }
    }, this);
    // reset collider grid keys after deleting from main grid
    collider._positionInGridKeys = [];
  },
  _getColliderKeysInGrid: function(collider) {
    var keyX, keyY,
        x = 0,
        y = 0,
        posX = collider._AABB.pos.x - collider._AABB.half.x,
        posY = collider._AABB.pos.y - collider._AABB.half.y,
        cWidth = collider._AABB.half.x * 2,
        cHeight = collider._AABB.half.y * 2,
        cellSize = this._cellSize,
        keys = [];

    for(;;) {
      keyX = Math.floor((x+posX) / cellSize);
      keyY = Math.floor((y+posY) / cellSize);

      keys.push('x'+keyX+'y'+keyY);

      if(x === cWidth && y === cHeight) {
        break;
      }

      if(x === cWidth) {
        x = 0;
        y += cellSize;
        if(y > cHeight) {
          y = cHeight;
        }
      }
      else {
        x += cellSize;
      }

      if(x > cWidth) {
        x = cWidth;
      }
    }
    return keys;
  }
};

Axis2D.Collider = function(axisWorld, centerX, centerY, width, height) {
  Axis2D.typeCheck(axisWorld, 'axisWorld', Axis2D.World);
  Axis2D.typeCheck(centerX, 'centerX', 'Number');
  Axis2D.typeCheck(centerY, 'centerY', 'Number');
  Axis2D.typeCheck(width, 'width', 'Number');
  Axis2D.typeCheck(height, 'height', 'Number');

  this._axisWorld = axisWorld;

  this._AABB = new intersect.AABB({},{});
  this._AABB.pos.x = centerX || 0;
  this._AABB.pos.y = centerY || 0;
  this._AABB.half.x = (Math.abs(width) || axisWorld._grid._cellSize - 1) / 2;
  this._AABB.half.y = (Math.abs(height) || axisWorld._grid._cellSize - 1) / 2;

  this._delta = new intersect.Point(0, 0);

  this._responseType = 'slide';

  this._isTouching = {
    top: false,
    left: false,
    right: false,
    bottom: false
  };

  this._potentialHitColliders = [];

  this._isSensor = false;

  this._groupName = '';
  this._groupFilters = [];

  this._positionInGridKeys = [];
  this._hits = [];

  this.userData = undefined;
  this._collisionCallback = undefined;

  this._isDynamic = false;

  this._axisWorld._grid._placeColliderInGrid(this);
  this._axisWorld._colliders.push(this);
};

Axis2D.Collider.prototype = {
  moveTo: function(x, y) {
    this._delta.x = x - this._AABB.pos.x;
    this._delta.y = y - this._AABB.pos.y;

    if(this._delta.x || this._delta.y) {
      this.setAsDynamic();
    }
  },
  resize: function(width, height) {
    var hW = width / 2,
        hH = height / 2;

    // only if collider resizes up... else it's in same grid
    if(this._AABB.half.x !== hW && this._AABB.half.y !== hH) {
      this._AABB.half.x = width / 2;
      this._AABB.half.y = height / 2;
      this.setAsDynamic();
    }
  },
  setGroupName: function(name) {
    Axis2D.typeCheck(name, 'name', 'String');
    this._groupName = name;
  },
  setGroupFilters: function(names) {
    Axis2D.typeCheck(names, 'names', 'Array');
    this._groupFilters = names;
  },
  setResponseType: function(type) {
    Axis2D.typeCheck(type, 'type', 'String');

    if(Object.keys(this._axisWorld._responses).indexOf(type) === -1) {
      throw Error('response type does not exist in Axis2D World');
    }

    this._responseType = type;
  },
  getResponseType: function() {
    return this._responseType;
  },
  setCollisionCallback: function(callback) {
    Axis2D.typeCheck(callback, 'callback', 'Function');
    this._collisionCallback = callback;
  },
  getPosition: function() {
    return this._AABB.pos;
  },
  getWidth: function() {
    return this._AABB.half.x * 2;
  },
  getHeight: function() {
    return this._AABB.half.y * 2;
  },
  getHits: function() {
    return this._hits;
  },
  getTouches: function() {
    return this._isTouching;
  },
  setSensor: function(bool) {
    Axis2D.typeCheck(bool, 'bool', 'Boolean');
    this._isSensor = bool;
  },
  isSensor: function() {
    return this._isSensor;
  },
  setAsDynamic: function() {
    // Could be used on static colliders to push them from each other and
    // add hits.
    if(!this._isDynamic) {
      this._isDynamic = true;
      this._axisWorld._dynamicColliders.push(this);
    }
  },
  _placeInPotentialGrid: function() {
    // 1. move collider to the middle/center position
    // 2. make the collider take upp all the space it moved in
    // 3. place collider in the grid
    // 4. find potential hit colliders
    // 5. resize collider back and place it in the new coords
    var hW = this._AABB.half.x,
        hH = this._AABB.half.y,
        posX = this._AABB.pos.x,
        posY = this._AABB.pos.y;

    this._AABB.pos.x += this._delta.x / 2;
    this._AABB.pos.y += this._delta.y / 2;

    this._AABB.half.x = Math.abs(this._delta.x) / 2 + hW;
    this._AABB.half.y = Math.abs(this._delta.y) / 2 + hH;

    this._axisWorld._grid._placeColliderInGrid(this);

    this._positionInGridKeys.forEach(function(key){
      this._axisWorld._grid._cells[key].forEach(function(oc){
        if(this !== oc && this._potentialHitColliders.indexOf(oc) === -1) {
          this._potentialHitColliders.push(oc);
        }
      }, this);
    }, this);

    this._AABB.pos.x = posX;
    this._AABB.pos.y = posY;
    this._AABB.half.x = hW;
    this._AABB.half.y = hH;
  },
  _calculateTouches: function() {
    if(!this.isSensor()) {
      this._hits.forEach(function(hit){
        var oc = hit.collider,
            rf = this._groupFilters,
            otherNotInFilter = rf.indexOf(oc._groupName) === -1;

        if(!oc.isSensor() && otherNotInFilter) {
          if(hit.normal.x > 0) {
            this._isTouching.left = true;
          }
          else if(hit.normal.x < 0) {
            this._isTouching.right = true;
          }
          if(hit.normal.y > 0) {
            this._isTouching.top = true;
          }
          else if(hit.normal.y < 0) {
            this._isTouching.bottom = true;
          }
        }
      }, this);
    }
  },
  _addHit: function(hit) {
    for(var i = 0; i < this._hits.length; i++) {
      // prevent from adding another hit that contains same collider
      if(hit.collider === this._hits[i].collider) {
        return;
      }
    }
    this._hits.push(hit);
  },
  _sweepToDelta: function() {
    var cAABB = this._AABB,
        cDelta = this._delta,
        nearest = new intersect.Sweep(),
        otherColliders = this._potentialHitColliders;

    nearest.time = 1;
    nearest.pos.x = cAABB.pos.x + cDelta.x;
    nearest.pos.y = cAABB.pos.y + cDelta.y;

    this._placeInPotentialGrid();

    otherColliders.forEach(function(oc) {
      var sweep = oc._AABB.sweepAABB(cAABB, cDelta),
          crf = this._groupFilters,
          ocrf = oc._groupFilters,
          cFilterFound = ocrf.indexOf(this._groupName) !== -1,
          ocFilterFound = crf.indexOf(oc._groupName) !== -1;

      if(sweep.hit) {
        // bug in intersect?
        sweep.hit.delta.x += sweep.hit.normal.x * 0.99;
        sweep.hit.delta.y += sweep.hit.normal.y * 0.99;

        // sensor/filter check - ignore nearest
        if(this.isSensor() || cFilterFound) {
          this._addHits(sweep.hit, [oc]);

          // move all the way back for next sweep
          this._AABB.pos.x -= sweep.hit.delta.x;
          this._AABB.pos.y -= sweep.hit.delta.y;
        }
        else if (sweep.time < nearest.time) {
          // other sensor/filter check - ignore nearest
          if(oc.isSensor() || ocFilterFound) {
            this._addHits(sweep.hit, [oc]);

            // move all the way back for next sweep
            this._AABB.pos.x -= sweep.hit.delta.x;
            this._AABB.pos.y -= sweep.hit.delta.y;
          }
          else {
            sweep.hit.collider = oc;
            nearest = sweep;
          }
        }
      }
    }, this);

    if(nearest.hit) {
      this._addHits(nearest.hit, otherColliders);
    }

    return nearest;
  },
  _addHits: function(sweepHit, otherColliders) {
    // add a little to the delta for adding all colliders hitting,
    // because sweep can only hit one collider at a time
    this._AABB.pos.x += sweepHit.delta.x - sweepHit.normal.x;
    this._AABB.pos.y += sweepHit.delta.y - sweepHit.normal.y;

    otherColliders.forEach(function(colliderB){
      var hitA,
          hitB = this._AABB.intersectAABB(colliderB._AABB);

      if(hitB) {
        hitA = colliderB._AABB.intersectAABB(this._AABB);

        // we already got right delta
        hitA.delta = sweepHit.delta;

        // overwrite for collision callbacks to access collider
        hitA.collider = colliderB;
        hitB.collider = this;

        // colliderA was moved by adding a normal. so hitB delta will be wrong.
        // if colliderB is dynamic and moves into colliderA next, it should
        // be ok to set deltas to zero. _addHit will not create second
        // hit with same collider
        hitB.delta.x = 0;
        hitB.delta.y = 0;

        this._addHit(hitA);
        colliderB._addHit(hitB);

        if(this._axisWorld._collidersHit.indexOf(this) === -1) {
          this._axisWorld._collidersHit.push(this);
        }

        if(this._axisWorld._collidersHit.indexOf(colliderB) === -1) {
          this._axisWorld._collidersHit.push(colliderB);
        }
      }
    }, this);

    // fix position back to first hit
    this._AABB.pos.x += sweepHit.normal.x;
    this._AABB.pos.y += sweepHit.normal.y;
  }
};

Axis2D.DebugDraw = function DebugDraw(axisWorld) {
  Axis2D.typeCheck(axisWorld, 'axisWorld', Axis2D.World);

  this._axisWorld = axisWorld;

  this._colliderCallback = undefined;
  this._gridCallback = undefined;

  this._axisWorld._debugDraw = this;
};

Axis2D.DebugDraw.prototype = {
  setColliderCallback: function(callback) {
    Axis2D.typeCheck(callback, 'callback', 'Function');
    this._colliderCallback = callback;
  },
  setGridCallback: function(callback) {
    Axis2D.typeCheck(callback, 'callback', 'Function');
    this._gridCallback = callback;
  },
  _draw: function() {
    if(this._colliderCallback) {
      this._getColliders(this._colliderCallback);
    }
    if(this._gridCallback) {
      this._getGrid(this._gridCallback);
    }
  },
  _getColliders: function(callback) {
    var x, y, cX, cY, w, h,
        world = this._axisWorld;

    world._colliders.forEach(function(c){
      x = c._AABB.pos.x - c._AABB.half.x;
      y = c._AABB.pos.y - c._AABB.half.y;
      cX = x + c._AABB.half.x;
      cY = y + c._AABB.half.y;
      w = c._AABB.half.x * 2;
      h = c._AABB.half.y * 2;

      callback(x, y, w, h, c.isSensor());
    }, this);
  },
  _getGrid: function(callback) {
    var g, key, x, y, split,
        world = this._axisWorld,
        cellSize = world._grid._cellSize;

    for(key in world._grid._cells) {
      g = world._grid._cells[key];
      split = key.split(/(\-?\d*)/);
      x = split[1] * cellSize;
      y = split[3] * cellSize;

      callback(x, y, cellSize, cellSize, g.length);
    }
  }
};
